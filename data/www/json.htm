<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="dark light">
<link rel="stylesheet" href="/styles.css">
<style>
  table {
    width: 80%;
    border-collapse: collapse;
    margin: auto;
  }
  th, td {
    padding: 8px;
    border: 1px solid #ddd;
    text-align: left;
  }
  th {
    background-color: #f4f4f4;
  }
  @media (prefers-color-scheme: dark) {
    th {
      background-color: #333;
    }
  }
</style>
<title>JSON Data Table</title>
</head>
<body>
<h2>JSON Data Table</h2>
<table id="dataTable">
  <thead>
    <tr id="headerRow"></tr>
  </thead>
  <tbody>
  </tbody>
</table>
<script>
// Utility to calculate leaf row counts while treating arrays as single entries
function calculateRowCounts(obj) {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj) && !obj.some(item => typeof item === "object")) {
    return 1; // Count as 1 if primitive or a simple array
  }
  let totalRows = 0;
  for (const value of Object.values(obj)) {
    totalRows += calculateRowCounts(value);
  }
  return totalRows;
}

// Recursive function to create rows for leaf nodes with accurate rowspan for parents
function createRows(data, tableBody, level = 0, parentCells = [], maxDepth) {
  Object.entries(data).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      const rowCount = calculateRowCounts(value);
      createRows(value, tableBody, level + 1, [...parentCells, { name: key, count: rowCount }], maxDepth);
    } else {
      const row = document.createElement("tr");

      // Apply row spans for parent cells accurately
      parentCells.forEach((parent, index) => {
        if (index >= level) return;
        if (parent.count > 0) {
          const cell = document.createElement("td");
          cell.rowSpan = parent.count;
          cell.textContent = parent.name;
          row.appendChild(cell);
          parent.count = 0; // Clear count for other rows
        }
      });

      // Add current level cell for the key
      const keyCell = document.createElement("td");
      keyCell.textContent = key;
      row.appendChild(keyCell);

      const valueCell = document.createElement("td");
      valueCell.textContent = Array.isArray(value) ? value.join(", ") : value;
      row.appendChild(valueCell);

      // Add empty cells to align with maxDepth
      for (let i = level + 2; i < maxDepth; i++) {
        const emptyCell = document.createElement("td");
        row.appendChild(emptyCell);
      }

      tableBody.appendChild(row);
    }
  });
}

// Populate header row based on calculated depth
function populateHeaderRow(depth) {
  const headerRow = document.getElementById("headerRow");
  headerRow.innerHTML = ""; // Clear existing headers
  for (let i = 1; i <= depth; i++) {
    const headerCell = document.createElement("th");
    headerCell.textContent = `Level ${i}`;
    headerRow.appendChild(headerCell);
  }
}

// Fetch JSON data and populate the table
async function fetchDataAndPopulateTable() {
  try {
    const response = await fetch('/json');
    if (!response.ok) throw new Error(`Error fetching data: ${response.statusText}`);

    const jsonData = await response.json();
    const depth = calculateDepth(jsonData); // Total column depth
    populateHeaderRow(depth);

    const tableBody = document.getElementById("dataTable").querySelector("tbody");
    tableBody.innerHTML = ""; // Clear previous rows
    createRows(jsonData, tableBody, 0, [], depth);
  } catch (error) {
    console.error(error);
  }
}

// Calculate maximum depth of JSON structure
function calculateDepth(obj, depth = 0) {
  if (typeof obj !== "object" || obj === null) return depth;
  let maxDepth = depth;
  for (const value of Object.values(obj)) {
    maxDepth = Math.max(maxDepth, calculateDepth(value, depth + 1));
  }
  return maxDepth;
}

// Fetch data on page load
window.onload = fetchDataAndPopulateTable;
</script>
</body>
</html>